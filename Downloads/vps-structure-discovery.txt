#!/bin/bash
# VPS Structure Discovery & Validation Script
# This script maps out your actual deployment structure and validates services
# Run this on your VPS to understand the real setup

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Output file for detailed report
REPORT_FILE="/tmp/vps-structure-report-$(date +%Y%m%d-%H%M%S).txt"

# Function to print section headers
print_header() {
    echo -e "\n${BOLD}${BLUE}==== $1 ====${NC}\n"
    echo -e "\n==== $1 ====" >> "$REPORT_FILE"
}

# Function to print success messages
print_success() {
    echo -e "${GREEN}✓ $1${NC}"
    echo "✓ $1" >> "$REPORT_FILE"
}

# Function to print error messages
print_error() {
    echo -e "${RED}✗ $1${NC}"
    echo "✗ $1" >> "$REPORT_FILE"
}

# Function to print warning messages
print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
    echo "⚠ $1" >> "$REPORT_FILE"
}

# Function to print info messages
print_info() {
    echo -e "${CYAN}ℹ $1${NC}"
    echo "ℹ $1" >> "$REPORT_FILE"
}

# Start the discovery
echo -e "${BOLD}${CYAN}==================================${NC}"
echo -e "${BOLD}${CYAN}  VPS Structure Discovery Tool    ${NC}"
echo -e "${BOLD}${CYAN}==================================${NC}"
echo "Report will be saved to: $REPORT_FILE"

# System Information
print_header "SYSTEM INFORMATION"
echo "Hostname: $(hostname)"
echo "IP Address: $(hostname -I | awk '{print $1}')"
echo "Public IP: $(curl -s ifconfig.me 2>/dev/null || echo "Unable to determine")"
echo "OS: $(lsb_release -d | cut -f2)"
echo "Kernel: $(uname -r)"
echo "Current User: $(whoami)"
echo "Current Directory: $(pwd)"
echo "Date: $(date)"

# Find Dashboard Location
print_header "FINDING YOUR DASHBOARD"

# Common locations to check
POSSIBLE_LOCATIONS=(
    "/my-working-prototype-dashbaord"
    "/my-working-prototype-dashboard"
    "/opt/risk-platform"
    "/opt/cyber-trust-dashboard"
    "/var/www/dashboard"
    "/home/*/dashboard"
    "/root/dashboard"
    "/app"
)

DASHBOARD_FOUND=""
for location in "${POSSIBLE_LOCATIONS[@]}"; do
    if [ -d "$location" ]; then
        print_success "Found directory: $location"
        # Check for React/Node indicators
        if [ -f "$location/package.json" ]; then
            print_info "  └─ Contains package.json"
            DASHBOARD_FOUND="$location"
        fi
        if [ -d "$location/src" ]; then
            print_info "  └─ Contains src/ directory"
        fi
        if [ -d "$location/build" ]; then
            print_info "  └─ Contains build/ directory"
        fi
        if [ -f "$location/docker-compose.yml" ] || [ -f "$location/docker-compose.yaml" ]; then
            print_info "  └─ Contains docker-compose file"
        fi
    fi
done

# Also search for any directory with package.json
print_info "Searching for Node.js projects..."
find / -maxdepth 3 -name "package.json" -type f 2>/dev/null | while read -r package_file; do
    dir=$(dirname "$package_file")
    if [[ ! "$dir" =~ node_modules ]]; then
        print_info "Found Node.js project at: $dir"
        # Check if it's the dashboard by looking for React
        if grep -q "react" "$package_file" 2>/dev/null; then
            print_success "  └─ This appears to be a React project!"
            DASHBOARD_FOUND="$dir"
        fi
    fi
done

# Directory Structure Analysis
if [ -n "$DASHBOARD_FOUND" ]; then
    print_header "DASHBOARD STRUCTURE at $DASHBOARD_FOUND"
    
    cd "$DASHBOARD_FOUND" || exit
    
    # Show directory tree (limited depth)
    if command -v tree &> /dev/null; then
        tree -L 2 -d
    else
        print_info "Directory structure:"
        find . -maxdepth 2 -type d | sed 's|^\./||' | grep -v '^\.$' | sort | sed 's/^/  /'
    fi
    
    # Check for important files
    print_info "\nKey files present:"
    [ -f "package.json" ] && print_success "package.json"
    [ -f "docker-compose.yml" ] && print_success "docker-compose.yml"
    [ -f "docker-compose.yaml" ] && print_success "docker-compose.yaml"
    [ -f "Dockerfile" ] && print_success "Dockerfile"
    [ -f ".env" ] && print_success ".env file"
    [ -d "src" ] && print_success "src/ directory"
    [ -d "build" ] && print_success "build/ directory"
    [ -d "public" ] && print_success "public/ directory"
    [ -d "node_modules" ] && print_success "node_modules/ directory"
    [ -d "nginx" ] && print_success "nginx/ directory"
    
    # Check package.json for project details
    if [ -f "package.json" ]; then
        print_info "\nProject details from package.json:"
        echo "  Name: $(grep '"name"' package.json | head -1 | cut -d'"' -f4)"
        echo "  Version: $(grep '"version"' package.json | head -1 | cut -d'"' -f4)"
    fi
fi

# Docker Status
print_header "DOCKER STATUS"

# Check if Docker is installed
if command -v docker &> /dev/null; then
    print_success "Docker is installed"
    echo "Docker version: $(docker --version)"
    
    # Check Docker service
    if systemctl is-active --quiet docker; then
        print_success "Docker daemon is running"
    else
        print_error "Docker daemon is not running"
    fi
    
    # Check Docker Compose
    if command -v docker-compose &> /dev/null; then
        print_success "Docker Compose is installed (standalone)"
        echo "Version: $(docker-compose --version)"
    elif docker compose version &> /dev/null 2>&1; then
        print_success "Docker Compose is installed (plugin)"
        echo "Version: $(docker compose version)"
    else
        print_error "Docker Compose is not installed"
    fi
else
    print_error "Docker is not installed"
fi

# Running Containers
print_header "RUNNING CONTAINERS"

if command -v docker &> /dev/null; then
    CONTAINER_COUNT=$(docker ps -q | wc -l)
    if [ "$CONTAINER_COUNT" -gt 0 ]; then
        print_success "Found $CONTAINER_COUNT running container(s)"
        echo ""
        docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
    else
        print_warning "No running containers found"
        
        # Check for stopped containers
        STOPPED_COUNT=$(docker ps -a -q | wc -l)
        if [ "$STOPPED_COUNT" -gt 0 ]; then
            print_info "Found $STOPPED_COUNT stopped container(s)"
            docker ps -a --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"
        fi
    fi
    
    # Docker networks
    print_info "\nDocker networks:"
    docker network ls --format "table {{.Name}}\t{{.Driver}}\t{{.Scope}}"
    
    # Docker volumes
    print_info "\nDocker volumes:"
    docker volume ls --format "table {{.Driver}}\t{{.Name}}"
fi

# Process Checking (non-Docker services)
print_header "RUNNING PROCESSES"

# Check for Node.js processes
if pgrep -f "node" > /dev/null; then
    print_success "Node.js processes found:"
    ps aux | grep node | grep -v grep | head -3
else
    print_info "No Node.js processes running directly (may be in containers)"
fi

# Check for Nginx
if pgrep -f "nginx" > /dev/null; then
    print_success "Nginx processes found:"
    ps aux | grep nginx | grep -v grep | head -3
else
    print_info "No Nginx processes running directly (may be in containers)"
fi

# Port Analysis
print_header "PORT ANALYSIS"

echo "Checking commonly used ports..."
for port in 80 443 3000 3001 8080 8081 5432 6379 9090 3389; do
    if netstat -tuln 2>/dev/null | grep -q ":$port "; then
        print_success "Port $port is in use"
        # Try to identify what's using it
        if command -v lsof &> /dev/null; then
            SERVICE=$(lsof -i :$port 2>/dev/null | grep LISTEN | awk '{print $1}' | head -1)
            [ -n "$SERVICE" ] && echo "    └─ Used by: $SERVICE"
        fi
    else
        print_info "Port $port is available"
    fi
done

# File System Analysis
print_header "FILE SYSTEM & DISK USAGE"

# Overall disk usage
echo "Disk usage:"
df -h | grep -E '^/dev/' | head -5

# Find large directories
echo -e "\nLargest directories:"
du -h / 2>/dev/null | sort -rh | head -10 | grep -v "^du:"

# Environment Variables
print_header "ENVIRONMENT CONFIGURATION"

# Check for .env files
echo "Searching for .env files..."
find / -maxdepth 4 -name ".env*" -type f 2>/dev/null | while read -r env_file; do
    print_info "Found: $env_file"
    echo "  Size: $(ls -lh "$env_file" | awk '{print $5}')"
    echo "  Modified: $(ls -lh "$env_file" | awk '{print $6, $7, $8}')"
done

# Nginx Configuration
print_header "NGINX CONFIGURATION"

# Find Nginx config files
NGINX_DIRS=("/etc/nginx" "/usr/local/nginx/conf" "/opt/nginx/conf")
for dir in "${NGINX_DIRS[@]}"; do
    if [ -d "$dir" ]; then
        print_success "Found Nginx config directory: $dir"
        # Check for site configs
        if [ -d "$dir/sites-enabled" ]; then
            print_info "Sites enabled:"
            ls -la "$dir/sites-enabled/" | tail -n +2
        fi
        if [ -d "$dir/conf.d" ]; then
            print_info "Configs in conf.d:"
            ls -la "$dir/conf.d/" | tail -n +2
        fi
    fi
done

# Also check in project directories
if [ -n "$DASHBOARD_FOUND" ]; then
    if [ -d "$DASHBOARD_FOUND/nginx" ]; then
        print_success "Found project Nginx config: $DASHBOARD_FOUND/nginx"
        ls -la "$DASHBOARD_FOUND/nginx/" | tail -n +2
    fi
fi

# Git Repository Check
print_header "GIT REPOSITORY STATUS"

if [ -n "$DASHBOARD_FOUND" ]; then
    cd "$DASHBOARD_FOUND" || exit
    if [ -d ".git" ]; then
        print_success "Git repository found"
        echo "Remote: $(git remote -v | head -1)"
        echo "Branch: $(git branch --show-current)"
        echo "Last commit: $(git log -1 --oneline)"
        
        # Check for uncommitted changes
        if [ -n "$(git status --porcelain)" ]; then
            print_warning "Uncommitted changes detected"
        else
            print_success "Working directory clean"
        fi
    else
        print_info "Not a git repository"
    fi
fi

# Service Health Checks
print_header "SERVICE HEALTH CHECKS"

# Try common health endpoints
HEALTH_ENDPOINTS=(
    "http://localhost/health"
    "http://localhost/api/health"
    "http://localhost:3000/health"
    "http://localhost:3001/health"
    "http://localhost:8080/health"
)

for endpoint in "${HEALTH_ENDPOINTS[@]}"; do
    if curl -s -f -o /dev/null "$endpoint" 2>/dev/null; then
        print_success "Health check OK: $endpoint"
        RESPONSE=$(curl -s "$endpoint" 2>/dev/null | head -c 100)
        echo "  Response: $RESPONSE..."
    fi
done

# Recommendations
print_header "RECOMMENDATIONS"

echo -e "${BOLD}Based on the scan, here are the recommendations:${NC}\n"

# Check if we found the dashboard
if [ -n "$DASHBOARD_FOUND" ]; then
    echo "1. ${GREEN}Dashboard Location:${NC} $DASHBOARD_FOUND"
    echo "   This should be your working directory for updates"
    echo ""
else
    echo "1. ${YELLOW}Dashboard Location:${NC} Could not definitively locate your dashboard"
    echo "   You may need to manually specify the location"
    echo ""
fi

# Check Docker status
if docker ps -q | wc -l | grep -q "^0$"; then
    echo "2. ${YELLOW}Docker Status:${NC} No containers running"
    echo "   You may need to run: docker-compose up -d"
    echo ""
else
    echo "2. ${GREEN}Docker Status:${NC} Containers are running"
    echo ""
fi

# Check for build directory
if [ -n "$DASHBOARD_FOUND" ] && [ ! -d "$DASHBOARD_FOUND/build" ]; then
    echo "3. ${YELLOW}Build Directory:${NC} No build directory found"
    echo "   You need to run: npm run build"
    echo ""
elif [ -d "$DASHBOARD_FOUND/build" ]; then
    echo "3. ${GREEN}Build Directory:${NC} Build directory exists"
    echo "   Last modified: $(stat -c %y "$DASHBOARD_FOUND/build" | cut -d' ' -f1)"
    echo ""
fi

# Summary
print_header "SUMMARY FOR DEPLOYMENT GUIDE"

echo "Based on this scan, your deployment commands should be:"
echo ""
echo "${BOLD}Local Development (your machine):${NC}"
echo "  cd /path/to/your/local/dashboard"
echo "  npm run build"
echo ""
echo "${BOLD}Transfer to VPS:${NC}"
if [ -n "$DASHBOARD_FOUND" ]; then
    echo "  scp -r ./build/* root@$(hostname -I | awk '{print $1}'):$DASHBOARD_FOUND/build/"
else
    echo "  scp -r ./build/* root@$(hostname -I | awk '{print $1}'):/path/to/dashboard/build/"
fi
echo ""
echo "${BOLD}On VPS:${NC}"
if [ -n "$DASHBOARD_FOUND" ]; then
    echo "  cd $DASHBOARD_FOUND"
else
    echo "  cd /path/to/dashboard"
fi
echo "  docker-compose restart nginx  # For frontend changes"
echo "  docker-compose restart api    # For API changes"
echo ""

# Save report location
echo -e "\n${BOLD}${GREEN}Full report saved to: $REPORT_FILE${NC}"
echo "You can view it with: cat $REPORT_FILE"
echo ""
echo "To share this report, run:"
echo "cat $REPORT_FILE | nc termbin.com 9999"